"""ContractVisualizer - Architecture Document Generator.

Generates comprehensive architecture documentation from NodeRegistry
contracts, including Mermaid diagrams for visual representation.
"""
from __future__ import annotations

from typing import TYPE_CHECKING
from collections import defaultdict

if TYPE_CHECKING:
    from langgraph.graph.state import CompiledStateGraph
    from agent_contracts.registry import NodeRegistry
    from agent_contracts.contracts import NodeContract, TriggerCondition


class ContractVisualizer:
    """Generate architecture documentation from NodeRegistry contracts.
    
    Example:
        visualizer = ContractVisualizer(registry)
        doc = visualizer.generate_architecture_doc()
        with open("ARCHITECTURE.md", "w") as f:
            f.write(doc)
    """
    
    def __init__(self, registry: "NodeRegistry", graph: "CompiledStateGraph | None" = None):
        """Initialize visualizer.
        
        Args:
            registry: NodeRegistry with registered nodes
            graph: Optional compiled LangGraph for flow visualization
        """
        self.registry = registry
        self.graph = graph
    
    def generate_architecture_doc(self) -> str:
        """Generate complete architecture document.
        
        Returns:
            Markdown document with all sections
        """
        sections = [
            self._generate_header(),
            self.generate_langgraph_flow(),  # Added LangGraph flow
            self.generate_state_slices_section(),
            self.generate_hierarchy_diagram(),
            self.generate_dataflow_diagram(),
            self.generate_trigger_hierarchy(),
            self.generate_nodes_reference(),
            self._generate_footer(),
        ]
        return "\n\n---\n\n".join(s for s in sections if s)
    
    def _generate_header(self) -> str:
        """Generate document header."""
        return """# ğŸ—ï¸ Agent Architecture

> Auto-generated from `NodeRegistry` contracts"""
    
    def _generate_footer(self) -> str:
        """Generate document footer."""
        return "<sub>Generated by `agent-contracts` visualizer</sub>"
    
    def generate_langgraph_flow(self) -> str:
        """Generate LangGraph flow visualization from compiled graph."""
        if not self.graph:
            return ""
            
        try:
            mermaid = self.graph.get_graph().draw_mermaid()
            return f"""## ğŸ”— LangGraph Node Flow

> Auto-generated from compiled LangGraph

```mermaid
{mermaid}
```"""
        except Exception:
            return ""

    
    # =========================================================================
    # State Slices Section
    # =========================================================================
    
    def generate_state_slices_section(self) -> str:
        """Generate State Slices documentation.
        
        Collects all slices from node contracts and creates documentation.
        """
        # Collect slices from all nodes
        all_reads: set[str] = set()
        all_writes: set[str] = set()
        
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if contract:
                all_reads.update(contract.reads)
                all_writes.update(contract.writes)
        
        all_slices = sorted(all_reads | all_writes)
        
        if not all_slices:
            return ""
        
        # Build table
        lines = [
            "## ğŸ“¦ State Slices",
            "",
            "State is organized into isolated **slices** for separation of concerns.",
            "",
            "| Slice | Read By | Written By |",
            "|:------|:--------|:-----------|",
        ]
        
        for slice_name in all_slices:
            readers = [n for n in self.registry.get_all_nodes() 
                      if slice_name in (self.registry.get_contract(n).reads or [])]
            writers = [n for n in self.registry.get_all_nodes()
                      if slice_name in (self.registry.get_contract(n).writes or [])]
            
            readers_str = ", ".join(f"`{r}`" for r in readers)
            writers_str = ", ".join(f"`{w}`" for w in writers)
                
            lines.append(f"| `{slice_name}` | {readers_str or '-'} | {writers_str or '-'} |")
        
        return "\n".join(lines)
    
    def _build_slice_relationships(self) -> list[tuple[str, str, str]]:
        """Build slice relationships from node I/O patterns."""
        # Count how many nodes transform from one slice to another
        transform_counts: dict[tuple[str, str], int] = defaultdict(int)
        
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if not contract:
                continue
            
            for read_slice in contract.reads:
                for write_slice in contract.writes:
                    if read_slice != write_slice:
                        transform_counts[(read_slice, write_slice)] += 1
        
        # Sort by count and take top relationships
        sorted_transforms = sorted(
            transform_counts.items(), 
            key=lambda x: x[1], 
            reverse=True
        )[:10]  # Limit to 10 most common to avoid diagram clutter
        
        return [
            (src, dst, f"{count} nodes")
            for (src, dst), count in sorted_transforms
        ]
    
    # =========================================================================
    # Hierarchy Diagram
    # =========================================================================
    
    def generate_hierarchy_diagram(self) -> str:
        """Generate Supervisor-Node hierarchy diagram."""
        # Group nodes by supervisor
        supervisors: dict[str, list[str]] = defaultdict(list)
        
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if contract:
                supervisors[contract.supervisor].append(name)
        
        if not supervisors:
            return ""
        
        lines = [
            "## ğŸ¯ System Hierarchy",
            "",
            "```mermaid",
            "flowchart TB",
        ]
        
        # Generate subgraphs for each supervisor
        for sup_name, nodes in sorted(supervisors.items()):
            safe_sup = self._safe_id(sup_name)
            lines.append(f'    subgraph {safe_sup}["ğŸ¯ {sup_name.replace("_", " ").title()}"]')
            lines.append("        direction LR")
            
            for node_name in nodes:
                contract = self.registry.get_contract(node_name)
                icon = self._get_node_icon(contract)
                safe_node = self._safe_id(node_name)
                lines.append(f'        {safe_node}["{icon} {node_name}"]')
            
            lines.append("    end")
        
        # Add terminal node styling
        terminal_nodes = [
            self._safe_id(n) for n in self.registry.get_all_nodes()
            if self.registry.get_contract(n) and self.registry.get_contract(n).is_terminal
        ]
        if terminal_nodes:
            lines.append("")
            lines.append("    classDef terminal fill:#e94560,stroke:#16213e,color:#fff")
            lines.append(f"    class {','.join(terminal_nodes)} terminal")
        
        lines.append("```")
        
        return "\n".join(lines)
    
    def _get_node_icon(self, contract: "NodeContract | None") -> str:
        """Get emoji icon for node based on its properties.
        
        Combines icons: [LLM?] + [Terminal/Domain Type]
        """
        if not contract:
            return "ğŸ“¦"
        
        # 1. Determine base icon (Type/Domain)
        if contract.is_terminal:
            base_icon = "ğŸ”š"
        elif "search" in contract.name.lower():
            base_icon = "ğŸ”"
        elif "interview" in contract.name.lower():
            base_icon = "ğŸ’¬"
        elif "like" in contract.name.lower() or "heart" in contract.name.lower():
            base_icon = "â¤ï¸"
        elif "card" in contract.name.lower():
            base_icon = "ğŸƒ"
        else:
            base_icon = "ğŸ“¦"
            
        # 2. Add LLM indicator if applicable
        if contract.requires_llm:
            return f"ğŸ¤–{base_icon}"
            
        return base_icon
    
    def _safe_id(self, name: str) -> str:
        """Convert name to safe Mermaid ID."""
        return name.replace("-", "_").replace(" ", "_")
    
    # =========================================================================
    # Data Flow Diagram
    # =========================================================================
    
    def generate_dataflow_diagram(self) -> str:
        """Generate data flow diagram showing key data paths.
        
        Shows:
        - Slices as central data stores
        - Entry points (nodes reading request)
        - Terminal nodes (marked with is_terminal)
        - Cross-supervisor data connections
        """
        # Group nodes by supervisor
        supervisors: dict[str, list[str]] = defaultdict(list)
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if contract:
                supervisors[contract.supervisor].append(name)
        
        if not supervisors:
            return ""
        
        lines = [
            "## ğŸ”€ Data Flow",
            "",
            "> Key data paths through the system",
            "",
            "```mermaid",
            "flowchart TB",
        ]
        
        # Find key nodes: entry points (read request) and terminals
        entry_nodes: list[str] = []
        terminal_nodes: list[str] = []
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if contract:
                if "request" in contract.reads:
                    entry_nodes.append(name)
                if contract.is_terminal:
                    terminal_nodes.append(name)
        
        # Add slices (excluding _internal)
        key_slices = ["request", "response"]
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if contract:
                for s in contract.reads + contract.writes:
                    if not s.startswith('_') and s not in key_slices:
                        key_slices.append(s)
        
        # Slices subgraph
        lines.append('    subgraph slices["ğŸ“¦ State"]')
        for slice_name in sorted(set(key_slices)):
            icon = "ğŸ“¥" if slice_name == "request" else "ğŸ“¤" if slice_name == "response" else "ğŸ“"
            slice_id = f"slice_{self._safe_id(slice_name)}"
            lines.append(f'        {slice_id}[("{icon} {slice_name}")]')
        lines.append("    end")
        lines.append("")
        
        # Add supervisor subgraphs with their nodes
        for sup_name, nodes in sorted(supervisors.items()):
            safe_sup = f"sup_{self._safe_id(sup_name)}"
            lines.append(f'    subgraph {safe_sup}["ğŸ¯ {sup_name}"]')
            lines.append("        direction LR")
            for node_name in nodes:
                contract = self.registry.get_contract(node_name)
                icon = self._get_node_icon(contract)
                safe_node = self._safe_id(node_name)
                lines.append(f'        {safe_node}["{icon} {node_name}"]')
            lines.append("    end")
        
        lines.append("")
        
        # Add edges: request -> entry nodes
        lines.append("    %% Entry points")
        for node_name in entry_nodes:  # Show all entry points
            lines.append(f"    slice_request --> {self._safe_id(node_name)}")
        
        # Add edges: nodes writing to response -> response
        lines.append("    %% Response outputs")
        response_writers: list[str] = []
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if contract and "response" in contract.writes:
                response_writers.append(name)
        for node_name in response_writers:  # Show all response writers
            lines.append(f"    {self._safe_id(node_name)} --> slice_response")
        
        # Add edges for other slices (excluding request/response/_internal)
        lines.append("    %% Slice data flows")
        other_slices = [s for s in key_slices if s not in ["request", "response"]]
        for slice_name in other_slices:
            slice_id = f"slice_{self._safe_id(slice_name)}"
            # Find readers and writers for this slice
            readers: list[str] = []
            writers: list[str] = []
            for name in self.registry.get_all_nodes():
                contract = self.registry.get_contract(name)
                if contract:
                    if slice_name in contract.reads:
                        readers.append(name)
                    if slice_name in contract.writes:
                        writers.append(name)
            # Add writer -> slice edges
            for node_name in writers:
                lines.append(f"    {self._safe_id(node_name)} -.-> {slice_id}")
            # Add slice -> reader edges
            for node_name in readers:
                lines.append(f"    {slice_id} -.-> {self._safe_id(node_name)}")
        
        # Styling
        lines.extend([
            "",
            "    classDef slice fill:#f5f5f5,stroke:#999",
            "    classDef terminal fill:#e94560,stroke:#16213e,color:#fff",
        ])
        terminal_ids = [self._safe_id(n) for n in terminal_nodes]
        if terminal_ids:
            lines.append(f"    class {','.join(terminal_ids)} terminal")
        
        lines.append("```")
        
        # Add detailed node dependencies in collapsible section
        lines.extend([
            "",
            "<details>",
            "<summary>ğŸ“Š Detailed Node Dependencies</summary>",
            "",
        ])
        
        # Build dependency table grouped by supervisor
        dependencies = self.registry.analyze_data_flow()
        
        for sup_name, nodes in sorted(supervisors.items()):
            sup_deps = [(n, dependencies.get(n, [])) for n in nodes if dependencies.get(n)]
            if not sup_deps:
                continue
                
            lines.append(f"**{sup_name}**")
            lines.append("")
            lines.append("| Node | Depends On (via shared slices) |")
            lines.append("|:-----|:-------------------------------|")
            
            for node_name, deps in sup_deps:
                if deps:
                    # Find shared slices for each dependency
                    dep_info = []
                    node_contract = self.registry.get_contract(node_name)
                    for dep in deps:  # Show all dependencies
                        dep_contract = self.registry.get_contract(dep)
                        if node_contract and dep_contract:
                            shared = set(node_contract.reads) & set(dep_contract.writes)
                            shared_str = ", ".join(sorted(s for s in shared if not s.startswith('_')))
                            if shared_str:
                                dep_info.append(f"`{dep}` ({shared_str})")
                            else:
                                dep_info.append(f"`{dep}`")
                    if dep_info:
                        lines.append(f"| `{node_name}` | {', '.join(dep_info)} |")
            
            lines.append("")
        
        lines.extend([
            "</details>",
        ])
        
        return "\n".join(lines)
    
    # =========================================================================
    # Trigger Hierarchy
    # =========================================================================
    
    def generate_trigger_hierarchy(self) -> str:
        """Generate trigger hierarchy documentation."""
        # Group by supervisor
        supervisors: dict[str, list[tuple[str, "NodeContract"]]] = defaultdict(list)
        
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if contract:
                supervisors[contract.supervisor].append((name, contract))
        
        if not supervisors:
            return ""
        
        lines = [
            "## âš¡ Trigger Hierarchy",
            "",
            "> Nodes are evaluated by **priority** (highest first)",
        ]
        
        for sup_name, nodes in sorted(supervisors.items()):
            lines.extend([
                "",
                f"### ğŸ¯ {sup_name.replace('_', ' ').title()}",
                "",
                "| Priority | Node | Condition | Hint |",
                "|:--------:|:-----|:----------|:-----|",
            ])
            
            # Sort nodes by highest trigger priority
            def get_max_priority(item: tuple[str, "NodeContract"]) -> int:
                _, contract = item
                if not contract.trigger_conditions:
                    return -1
                return max(c.priority for c in contract.trigger_conditions)
            
            sorted_nodes = sorted(nodes, key=get_max_priority, reverse=True)
            
            for name, contract in sorted_nodes:
                priority = get_max_priority((name, contract))
                priority_icon = self._get_priority_icon(priority)
                
                # Get condition summary
                condition = self._summarize_conditions(contract.trigger_conditions)
                hint = contract.get_llm_hints()[0] if contract.get_llm_hints() else "-"
                
                priority_str = f"{priority_icon} **{priority}**" if priority >= 0 else "ğŸŸ¢ _(default)_"
                lines.append(f"| {priority_str} | `{name}` | {condition} | {hint} |")
            
            # Add Mermaid diagram for this supervisor
            lines.extend([
                "",
                "<details>",
                f"<summary>ğŸ“Š {sup_name} Priority Chain</summary>",
                "",
                "```mermaid",
                "flowchart TD",
                f'    subgraph {self._safe_id(sup_name)}["{sup_name}"]',
                "        direction TB",
            ])
            
            prev_node = None
            for name, contract in sorted_nodes:
                priority = get_max_priority((name, contract))
                priority_icon = self._get_priority_icon(priority)
                safe_name = self._safe_id(name)
                lines.append(f'        {safe_name}["{priority_icon} P{priority}: {name}"]')
                
                if prev_node:
                    lines.append(f'        {prev_node} -->|"not matched"| {safe_name}')
                prev_node = safe_name
            
            lines.extend([
                "    end",
                "```",
                "",
                "</details>",
            ])
        
        return "\n".join(lines)
    
    def _get_priority_icon(self, priority: int) -> str:
        """Get priority indicator icon."""
        if priority >= 100:
            return "ğŸ”´"
        elif priority >= 50:
            return "ğŸŸ¡"
        elif priority >= 10:
            return "ğŸŸ¢"
        else:
            return "âšª"
    
    def _summarize_conditions(self, conditions: list["TriggerCondition"]) -> str:
        """Summarize trigger conditions for display."""
        if not conditions:
            return "_(default)_"
        
        # Get highest priority condition
        highest = max(conditions, key=lambda c: c.priority)
        
        parts = []
        if highest.when:
            for key, value in list(highest.when.items())[:2]:
                parts.append(f"`{key}={value}`")
        if highest.when_not:
            for key, value in list(highest.when_not.items())[:1]:
                parts.append(f"`{key}â‰ {value}`")
        
        return ", ".join(parts) if parts else "_(always)_"
    
    # =========================================================================
    # Nodes Reference
    # =========================================================================
    
    def generate_nodes_reference(self) -> str:
        """Generate nodes reference table."""
        nodes = self.registry.get_all_nodes()
        
        if not nodes:
            return ""
        
        lines = [
            "## ğŸ“š Nodes Reference",
            "",
            "| Node | Supervisor | Reads | Writes | LLM | Terminal |",
            "|:-----|:-----------|:------|:-------|:---:|:--------:|",
        ]
        
        for name in sorted(nodes):
            contract = self.registry.get_contract(name)
            if not contract:
                continue
            
            reads = ", ".join(f"`{r}`" for r in contract.reads) or "-"
            writes = ", ".join(f"`{w}`" for w in contract.writes) or "-"
            llm = "âœ…" if contract.requires_llm else ""
            terminal = "ğŸ”š" if contract.is_terminal else ""
            
            lines.append(f"| `{name}` | {contract.supervisor} | {reads} | {writes} | {llm} | {terminal} |")
        
        lines.extend([
            "",
            "<details>",
            "<summary>ğŸ” Legend</summary>",
            "",
            "- âœ… = Requires LLM",
            "- ğŸ”š = Terminal node (exits to END)",
            "- Reads/Writes = State slices accessed",
            "",
            "</details>",
        ])
        
        return "\n".join(lines)
